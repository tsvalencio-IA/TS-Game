<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AR KINECT TRILOGY: ULTIMATE</title>
    
    <!-- TensorFlow.js Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@4.16.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@4.16.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.16.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.2"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Russo+One&display=swap');

        body {
            background-color: #000;
            margin: 0;
            overflow: hidden;
            font-family: 'Russo One', sans-serif;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #webcam {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            filter: brightness(0.6) contrast(1.2);
            z-index: 0;
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none;
        }

        .interactive {
            pointer-events: auto !important;
        }

        .title-glitch {
            text-shadow: 2px 2px 0px #ff00ff, -2px -2px 0px #00ffff;
            animation: glitch 0.5s infinite alternate;
        }

        @keyframes glitch {
            0% { transform: skew(0deg); }
            20% { transform: skew(-2deg); }
            40% { transform: skew(2deg); }
            100% { transform: skew(0deg); }
        }

        .hud-panel {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #fff;
            box-shadow: 0 0 15px #00ffff;
            backdrop-filter: blur(5px);
        }

        .btn-arcade {
            background: linear-gradient(45deg, #ff0055, #ff00aa);
            border: 3px solid #fff;
            box-shadow: 0 5px 0 #990033;
            transition: transform 0.1s;
        }
        .btn-arcade:active {
            transform: translateY(5px);
            box-shadow: 0 0 0 #990033;
        }

        #damage-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: red;
            opacity: 0;
            pointer-events: none;
            z-index: 30;
            transition: opacity 0.1s;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="damage-overlay"></div>
    <video id="video-source" playsinline style="display:none;"></video>
    <video id="webcam" autoplay muted playsinline></video>
    <canvas id="game-canvas"></canvas>

    <div id="ui-layer" class="flex flex-col items-center justify-center">
        <!-- LOADER -->
        <div id="screen-loading" class="absolute inset-0 bg-black flex flex-col items-center justify-center interactive z-50">
            <h1 class="text-4xl text-cyan-400 animate-pulse mb-4">INICIALIZANDO SISTEMA AR</h1>
            <div class="w-64 h-4 bg-gray-800 rounded border border-cyan-500 overflow-hidden">
                <div id="loading-bar" class="h-full bg-cyan-400 w-0 transition-all duration-1000"></div>
            </div>
            <p class="text-gray-400 mt-4 text-sm">Carregando Neural Network (MoveNet)...</p>
            <p class="text-gray-600 text-xs mt-2">Permita o uso da c√¢mera quando solicitado.</p>
        </div>

        <!-- MENU -->
        <div id="screen-menu" class="hidden absolute inset-0 bg-black/80 flex-col items-center justify-center interactive z-40">
            <h1 class="text-6xl md:text-8xl text-white font-black title-glitch mb-12 text-center leading-tight">
                MOTION<br><span class="text-cyan-400">ARCADE</span>
            </h1>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 w-full max-w-5xl px-4">
                <button onclick="GameSystem.start('drive')" class="btn-arcade p-6 rounded-xl group hover:scale-105 transition-all">
                    <div class="text-4xl mb-2">üèéÔ∏è</div>
                    <h2 class="text-2xl text-white font-bold">NEON DRIVE</h2>
                    <p class="text-white/80 text-sm mt-2">Segure o volante imagin√°rio.</p>
                </button>
                <button onclick="GameSystem.start('run')" class="btn-arcade p-6 rounded-xl group hover:scale-105 transition-all" style="background: linear-gradient(45deg, #00aa55, #00ff55); box-shadow: 0 5px 0 #006633;">
                    <div class="text-4xl mb-2">üèÉ</div>
                    <h2 class="text-2xl text-white font-bold">TURBO RUN</h2>
                    <p class="text-white/80 text-sm mt-2">Corra no lugar fisicamente.</p>
                </button>
                <button onclick="GameSystem.start('dance')" class="btn-arcade p-6 rounded-xl group hover:scale-105 transition-all" style="background: linear-gradient(45deg, #5500aa, #aa00ff); box-shadow: 0 5px 0 #330066;">
                    <div class="text-4xl mb-2">üíÉ</div>
                    <h2 class="text-2xl text-white font-bold">JUST POSE</h2>
                    <p class="text-white/80 text-sm mt-2">Copie as poses e pegue orbes.</p>
                </button>
            </div>
        </div>

        <!-- HUD -->
        <div id="screen-hud" class="hidden absolute top-0 w-full p-4 flex justify-between items-start pointer-events-none">
            <div class="hud-panel p-4 rounded-lg">
                <div class="text-xs text-cyan-300 uppercase tracking-widest">Score</div>
                <div id="hud-score" class="text-4xl text-white font-mono">00000</div>
            </div>
            <div id="hud-message" class="absolute top-20 left-1/2 transform -translate-x-1/2 text-center">
                <h2 class="text-3xl text-yellow-400 font-black drop-shadow-lg animate-bounce">PREPARE-SE!</h2>
            </div>
            <div class="hud-panel p-2 rounded-lg">
                <button onclick="GameSystem.stop()" class="bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-4 rounded interactive">
                    SAIR
                </button>
            </div>
        </div>

        <!-- GAME OVER -->
        <div id="screen-gameover" class="hidden absolute inset-0 bg-red-900/90 flex flex-col items-center justify-center interactive z-50">
            <h1 class="text-6xl text-white font-black mb-4 title-glitch">GAME OVER</h1>
            <p class="text-2xl text-white mb-8">Score Final: <span id="final-score" class="text-yellow-300">0</span></p>
            <button onclick="GameSystem.showMenu()" class="btn-arcade py-4 px-12 rounded-full text-xl font-bold text-white">
                VOLTAR AO MENU
            </button>
        </div>
    </div>
</div>

<script>
// ========== POLYFILL PARA roundRect ==========
const ctxProto = CanvasRenderingContext2D.prototype;
if (!ctxProto.roundRect) {
    ctxProto.roundRect = function(x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath();
    };
}

// ========== RESTANTE DO SEU C√ìDIGO (SEM ALTERA√á√ïES) ==========
const Gfx = {
    drawCar: (ctx, x, y, scale, angle) => {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        ctx.rotate(angle);
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(-35, 10, 70, 40);
        ctx.fillStyle = '#ff0033';
        ctx.beginPath();
        ctx.moveTo(-30, 0);
        ctx.lineTo(30, 0);
        ctx.lineTo(35, 20);
        ctx.lineTo(-35, 20);
        ctx.fill();
        ctx.fillStyle = '#990000';
        ctx.fillRect(-20, -15, 40, 15);
        ctx.fillStyle = '#ff0000';
        ctx.shadowBlur = 10;
        ctx.shadowColor = 'red';
        ctx.fillRect(-32, 12, 20, 5);
        ctx.fillRect(12, 12, 20, 5);
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#ffff00';
        ctx.fillRect(-8, 12, 16, 6);
        ctx.restore();
    },
    drawRunner: (ctx, x, y, scale, frame) => {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';
        ctx.shadowBlur = 5;
        ctx.shadowColor = '#00ff00';
        const legOffset = Math.sin(frame * 0.5) * 10;
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-10, 20 + legOffset); ctx.lineTo(-10, 40 + legOffset); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(10, 20 - legOffset); ctx.lineTo(10, 40 - legOffset); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, -30); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, -25); ctx.lineTo(-15, -10 - legOffset); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, -25); ctx.lineTo(15, -10 + legOffset); ctx.stroke();
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(0, -40, 8, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
    },
    drawObstacle: (ctx, x, y, scale, type) => {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        ctx.fillStyle = '#333';
        ctx.strokeStyle = '#ffcc00';
        ctx.lineWidth = 2;
        ctx.fillRect(-20, -40, 40, 40);
        ctx.strokeRect(-20, -40, 40, 40);
        ctx.beginPath();
        ctx.moveTo(-20, -40); ctx.lineTo(20, 0);
        ctx.moveTo(20, -40); ctx.lineTo(-20, 0);
        ctx.stroke();
        ctx.restore();
    }
};

class MotionEngine {
    constructor() {
        this.detector = null;
        this.video = document.getElementById('video-source');
        this.webcamDisplay = document.getElementById('webcam');
        this.ready = false;
        this.currentPose = null;
    }
    async init() {
        const updateBar = (pct) => document.getElementById('loading-bar').style.width = `${pct}%`;
        updateBar(20);
        await tf.setBackend('webgl');
        updateBar(50);
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: 'user', width: 640, height: 480 },
            audio: false
        });
        this.video.srcObject = stream;
        this.webcamDisplay.srcObject = stream;
        await new Promise(r => this.video.onloadedmetadata = r);
        this.video.play();
        updateBar(70);
        const detectorConfig = { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING };
        this.detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, detectorConfig);
        updateBar(100);
        this.ready = true;
        this.loop();
    }
    async loop() {
        if (this.ready) {
            try {
                const poses = await this.detector.estimatePoses(this.video);
                if (poses && poses.length > 0) {
                    this.currentPose = poses[0];
                }
            } catch (e) { console.error(e); }
        }
        requestAnimationFrame(() => this.loop());
    }
    getData() {
        if (!this.currentPose) return null;
        const kp = this.currentPose.keypoints;
        const find = (name) => kp.find(k => k.name === name);
        const nose = find('nose');
        const lw = find('left_wrist');
        const rw = find('right_wrist');
        const ls = find('left_shoulder');
        const rs = find('right_shoulder');
        const minConf = 0.3;
        if (!nose || nose.score < minConf) return null;
        return { nose, wrists: { left: lw, right: rw }, shoulders: { left: ls, right: rs }, raw: kp };
    }
}

class GameDrive {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.score = 0;
        this.playerX = 0;
        this.speed = 0;
        this.maxSpeed = 120;
        this.roadPos = 0;
        this.curve = 0;
        this.trackSection = 0;
    }
    start() {
        this.score = 0;
        this.speed = 0;
        this.playerX = 0;
        this.setMsg("M√ÉOS COMO VOLANTE!");
    }
    setMsg(txt) {
        document.getElementById('hud-message').innerHTML = `<h2 class="text-3xl text-yellow-400 font-black drop-shadow-md">${txt}</h2>`;
    }
    update(motion) {
        const w = this.canvas.width;
        const h = this.canvas.height;
        let steer = 0;
        if (motion && motion.wrists.left.score > 0.3 && motion.wrists.right.score > 0.3) {
            const dy = motion.wrists.right.y - motion.wrists.left.y;
            steer = dy * 0.02;
            if (this.speed < this.maxSpeed) this.speed += 2;
        } else {
            if (this.speed > 0) this.speed -= 1;
            this.setMsg("CAD√ä SUAS M√ÉOS?");
        }
        this.playerX += steer * (this.speed / 100);
        this.roadPos += this.speed;
        if (this.roadPos > 2000) {
            this.trackSection = (Math.random() - 0.5) * 2;
            this.roadPos = 0;
        }
        this.curve += (this.trackSection - this.curve) * 0.01;
        this.playerX -= this.curve * (this.speed / 2000);
        if (Math.abs(this.playerX) > 1.2) {
            this.speed *= 0.8;
            document.getElementById('damage-overlay').style.opacity = 0.5;
            setTimeout(() => document.getElementById('damage-overlay').style.opacity = 0, 100);
            this.setMsg("CUIDADO!!");
        }
        this.score += Math.floor(this.speed / 10);
        this.draw(w, h, steer);
        return this.score;
    }
    draw(w, h, steer) {
        this.ctx.clearRect(0,0,w,h);
        const HorizonY = h * 0.4;
        const CenterX = w / 2;
        const gradSky = this.ctx.createLinearGradient(0,0,0,HorizonY);
        gradSky.addColorStop(0, '#000033');
        gradSky.addColorStop(1, '#ff0055');
        this.ctx.fillStyle = gradSky;
        this.ctx.fillRect(0,0,w,HorizonY);
        this.ctx.fillStyle = '#111';
        this.ctx.fillRect(0, HorizonY, w, h - HorizonY);
        this.ctx.fillStyle = '#333';
        this.ctx.beginPath();
        const roadTopX = CenterX + (this.curve * 300);
        const roadTopW = 20;
        const roadBotX = CenterX;
        const roadBotW = w * 1.5;
        this.ctx.moveTo(roadTopX - roadTopW, HorizonY);
        this.ctx.lineTo(roadTopX + roadTopW, HorizonY);
        this.ctx.lineTo(roadBotX + roadBotW, h);
        this.ctx.lineTo(roadBotX - roadBotW, h);
        this.ctx.fill();
        this.ctx.strokeStyle = '#ffcc00';
        this.ctx.lineWidth = 10;
        const lineOffset = (Date.now() * (this.speed/20)) % 100;
        this.ctx.beginPath();
        this.ctx.moveTo(roadTopX, HorizonY);
        this.ctx.quadraticCurveTo(CenterX + (this.curve * 100), (HorizonY + h)/2, CenterX - (this.playerX * w * 0.5), h + lineOffset);
        this.ctx.stroke();
        this.ctx.strokeStyle = 'cyan';
        this.ctx.lineWidth = 5;
        this.ctx.beginPath();
        this.ctx.arc(CenterX, h - 100, 60, 0, Math.PI*2);
        this.ctx.stroke();
        this.ctx.save();
        this.ctx.translate(CenterX, h - 100);
        this.ctx.rotate(steer * 2);
        this.ctx.fillStyle = 'cyan';
        this.ctx.fillRect(-50, -5, 100, 10);
        this.ctx.restore();
        Gfx.drawCar(this.ctx, CenterX, h - 80, 1.5, steer * 0.5);
    }
}

class GameRun {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.playerY = 0;
        this.runSpeed = 0;
        this.lane = 0;
        this.obstacles = [];
        this.distance = 0;
        this.score = 0;
        this.frameCount = 0;
    }
    start() {
        this.score = 0;
        this.obstacles = [];
        this.distance = 0;
        this.runSpeed = 0;
        this.setMsg("CORRA NO LUGAR!");
    }
    setMsg(txt) {
        document.getElementById('hud-message').innerHTML = `<h2 class="text-3xl text-green-400 font-black drop-shadow-md">${txt}</h2>`;
    }
    update(motion) {
        const w = this.canvas.width;
        const h = this.canvas.height;
        if (motion) {
            const noseY = motion.nose.y;
            const delta = Math.abs(noseY - this.playerY);
            if (delta > 2) this.runSpeed += delta * 0.5;
            this.playerY = noseY;
            if (motion.nose.x < 200) this.lane = -1;
            else if (motion.nose.x > 440) this.lane = 1;
            else this.lane = 0;
        }
        this.runSpeed *= 0.90;
        if (this.runSpeed < 1) this.runSpeed = 0;
        if (this.runSpeed > 50) this.runSpeed = 50;
        this.distance += this.runSpeed;
        this.score = Math.floor(this.distance / 10);
        this.frameCount++;
        if (this.frameCount % 60 === 0 && this.runSpeed > 10) {
            const lane = Math.floor(Math.random() * 3) - 1;
            this.obstacles.push({ lane: lane, z: 1000 });
        }
        for (let i = this.obstacles.length - 1; i >= 0; i--) {
            let obs = this.obstacles[i];
            obs.z -= this.runSpeed;
            if (obs.z < 50 && obs.z > -50 && this.lane === obs.lane) {
                this.runSpeed = 0;
                document.getElementById('damage-overlay').style.opacity = 0.8;
                setTimeout(() => document.getElementById('damage-overlay').style.opacity = 0, 200);
                this.score -= 100;
                this.obstacles.splice(i, 1);
                continue;
            }
            if (obs.z < -100) this.obstacles.splice(i, 1);
        }
        if (this.runSpeed < 5) this.setMsg("CORRA MAIS R√ÅPIDO!");
        else this.setMsg("");
        this.draw(w, h);
        return this.score;
    }
    draw(w, h) {
        this.ctx.clearRect(0,0,w,h);
        const cx = w/2, cy = h/2;
        this.ctx.fillStyle = '#002200';
        this.ctx.fillRect(0,0,w,h);
        this.ctx.strokeStyle = '#005500';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath(); this.ctx.moveTo(cx - 20, cy); this.ctx.lineTo(0, h); this.ctx.stroke();
        this.ctx.beginPath(); this.ctx.moveTo(cx + 20, cy); this.ctx.lineTo(w, h); this.ctx.stroke();
        this.obstacles.forEach(obs => {
            const scale = 1000 / (obs.z + 100);
            const x = cx + (obs.lane * 200 * scale);
            const y = cy + (100 * scale);
            if (scale > 0) Gfx.drawObstacle(this.ctx, x, y, scale * 2, 0);
        });
        const frame = Date.now() / (200 - this.runSpeed * 3);
        const playerRenderX = cx + (this.lane * 100);
        Gfx.drawRunner(this.ctx, playerRenderX, h - 100, 2, this.runSpeed > 1 ? frame : 0);
    }
}

class GameDance {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.score = 0;
        this.targets = [];
        this.lastSpawn = 0;
    }
    start() {
        this.score = 0;
        this.targets = [];
        this.setMsg("ACERTE AS BOLHAS!");
    }
    setMsg(txt) {
        document.getElementById('hud-message').innerHTML = `<h2 class="text-3xl text-purple-400 font-black drop-shadow-md">${txt}</h2>`;
    }
    update(motion) {
        const w = this.canvas.width;
        const h = this.canvas.height;
        const now = Date.now();
        if (now - this.lastSpawn > 1500) {
            this.targets.push({ x: Math.random() * (w - 100) + 50, y: Math.random() * (h - 200) + 50, r: 60, birth: now, hit: false });
            this.lastSpawn = now;
        }
        if (motion) {
            const hands = [motion.wrists.left, motion.wrists.right];
            this.targets.forEach(t => {
                if (t.hit) return;
                hands.forEach(hand => {
                    if (hand.score > 0.3) {
                        const hx = (1 - (hand.x / 640)) * w;
                        const hy = (hand.y / 480) * h;
                        const dist = Math.hypot(hx - t.x, hy - t.y);
                        if (dist < t.r) {
                            t.hit = true;
                            this.score += 500;
                            this.createExplosion(t.x, t.y);
                        }
                    }
                });
            });
        }
        this.targets = this.targets.filter(t => (now - t.birth) < 2000 && !t.hit);
        this.draw(w, h, motion);
        return this.score;
    }
    createExplosion(x, y) {
        const el = document.createElement('div');
        el.style.position = 'absolute';
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        el.style.width = '100px';
        el.style.height = '100px';
        el.style.background = 'radial-gradient(circle, #fff, transparent)';
        el.style.transform = 'translate(-50%, -50%)';
        el.style.pointerEvents = 'none';
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 200);
    }
    draw(w, h, motion) {
        this.ctx.clearRect(0,0,w,h);
        if (motion) {
            this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
            this.ctx.lineWidth = 5;
            const drawLine = (p1, p2) => {
                if(p1.score > 0.3 && p2.score > 0.3) {
                    const x1 = (1 - p1.x/640)*w, y1 = (p1.y/480)*h;
                    const x2 = (1 - p2.x/640)*w, y2 = (p2.y/480)*h;
                    this.ctx.beginPath(); this.ctx.moveTo(x1, y1); this.ctx.lineTo(x2, y2); this.ctx.stroke();
                }
            };
            const kp = motion.raw;
            drawLine(motion.wrists.left, kp[7]);
            drawLine(kp[7], motion.shoulders.left);
            drawLine(motion.shoulders.left, motion.shoulders.right);
            drawLine(motion.shoulders.right, kp[8]);
            drawLine(kp[8], motion.wrists.right);
        }
        this.targets.forEach(t => {
            const life = (Date.now() - t.birth) / 2000;
            const radius = t.r * (1 - life);
            this.ctx.beginPath();
            this.ctx.arc(t.x, t.y, radius, 0, Math.PI*2);
            this.ctx.fillStyle = `rgba(255, 0, 255, ${1-life})`;
            this.ctx.fill();
            this.ctx.strokeStyle = '#fff';
            this.ctx.stroke();
        });
    }
}

const GameSystem = {
    motion: new MotionEngine(),
    canvas: document.getElementById('game-canvas'),
    activeGame: null,
    loopId: null,
    init: async () => {
        const resize = () => {
            GameSystem.canvas.width = window.innerWidth;
            GameSystem.canvas.height = window.innerHeight;
        };
        window.addEventListener('resize', resize);
        resize();
        await GameSystem.motion.init();
        document.getElementById('screen-loading').classList.add('hidden');
        document.getElementById('screen-menu').classList.remove('hidden');
        document.getElementById('screen-menu').classList.add('flex');
    },
    start: (gameType) => {
        document.getElementById('screen-menu').classList.add('hidden');
        document.getElementById('screen-menu').classList.remove('flex');
        document.getElementById('screen-hud').classList.remove('hidden');
        document.getElementById('screen-gameover').classList.add('hidden');
        if (gameType === 'drive') GameSystem.activeGame = new GameDrive(GameSystem.canvas);
        if (gameType === 'run') GameSystem.activeGame = new GameRun(GameSystem.canvas);
        if (gameType === 'dance') GameSystem.activeGame = new GameDance(GameSystem.canvas);
        GameSystem.activeGame.start();
        GameSystem.loop();
    },
    stop: () => {
        cancelAnimationFrame(GameSystem.loopId);
        GameSystem.activeGame = null;
        GameSystem.showMenu();
    },
    showMenu: () => {
        document.getElementById('screen-hud').classList.add('hidden');
        document.getElementById('screen-gameover').classList.add('hidden');
        document.getElementById('screen-menu').classList.remove('hidden');
        document.getElementById('screen-menu').classList.add('flex');
        const ctx = GameSystem.canvas.getContext('2d');
        ctx.clearRect(0,0, GameSystem.canvas.width, GameSystem.canvas.height);
    },
    loop: () => {
        if (!GameSystem.activeGame) return;
        const poseData = GameSystem.motion.getData();
        const currentScore = GameSystem.activeGame.update(poseData);
        document.getElementById('hud-score').innerText = currentScore.toString().padStart(5, '0');
        GameSystem.loopId = requestAnimationFrame(GameSystem.loop);
    }
};

window.onload = () => GameSystem.init();
</script>
</body>
</html>

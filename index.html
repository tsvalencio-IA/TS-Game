<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>thIAguinho Wii: DELUXE EDITION</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Russo+One&family=Roboto:wght@300;400;700&display=swap');

        :root {
            --wii-bg: #e6e6e6;
            --wii-highlight: #68c9e6;
            --wii-gray: #b0b0b0;
        }

        /* RESET GERAL */
        body {
            background-color: #000;
            margin: 0; padding: 0;
            overflow: hidden; /* Trava rolagem */
            font-family: 'Roboto', sans-serif;
            touch-action: none; /* Desativa gestos do navegador */
            user-select: none;
            width: 100vw;
            height: 100dvh; /* Altura din√¢mica para mobile */
        }

        /* LAYER SYSTEM */
        #os-layer { 
            position: relative; width: 100%; height: 100%; 
            background: transparent; pointer-events: none; z-index: 50; 
        }
        
        #game-hardware { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 0; background: #000;
        }

        /* V√çDEO E CANVAS (COVER MODE) */
        #video-source { display: none; }
        #webcam {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; /* Preenche a tela toda sem esticar */
            transform: scaleX(-1); opacity: 0; transition: opacity 0.5s;
        }
        #game-canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            display: block;
        }

        /* TELAS DO SISTEMA */
        .screen {
            position: absolute; inset: 0;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            background: var(--wii-bg);
            pointer-events: auto;
            transition: opacity 0.3s, transform 0.3s;
        }
        .hidden { opacity: 0; pointer-events: none; z-index: -1; }

        /* TELA DE SEGURAN√áA (BOOT) */
        #screen-safety { background: #fff; text-align: center; color: #555; padding: 2rem; z-index: 100; }
        .safety-card { 
            border: 1px solid #ccc; padding: 2rem; 
            width: 90%; max-width: 600px; 
            background: #fff;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1); 
            border-radius: 8px;
        }

        /* MENU WII (GRID RESPONSIVO) */
        #screen-menu { 
            background: linear-gradient(#f2f2f2, #d9d9d9); 
            justify-content: flex-start; 
            padding-top: 5vh;
        }
        
        .wii-grid {
            display: grid;
            width: 95%; 
            height: 70%;
            gap: 8px;
            /* RESPONSIVIDADE DO GRID */
            grid-template-columns: repeat(2, 1fr); /* Mobile: 2 colunas */
            grid-template-rows: repeat(4, 1fr);
        }

        /* Tablet/Desktop: 4 colunas */
        @media (min-width: 768px) {
            .wii-grid {
                width: 80%;
                grid-template-columns: repeat(4, 1fr);
                grid-template-rows: repeat(3, 1fr);
                gap: 15px;
            }
        }

        .channel {
            background: #fff;
            border-radius: 12px;
            border: 1px solid #ccc;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer;
            position: relative; overflow: hidden;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.05);
            transition: transform 0.1s;
        }
        .channel:active { transform: scale(0.95); border-color: var(--wii-highlight); }
        
        .channel-icon { font-size: clamp(2rem, 5vw, 4rem); margin-bottom: 5px; } /* √çcone escala com a tela */
        .channel-name { font-size: clamp(0.6rem, 2vw, 0.9rem); color: #888; text-transform: uppercase; font-weight: bold; }
        .channel-empty { background: #eee; }

        /* BARRA INFERIOR */
        .bottom-bar {
            position: absolute; bottom: 0; width: 100%; height: 12%;
            background: #cdcdcd; border-top: 2px solid #fff;
            display: flex; align-items: center; justify-content: center;
            padding: 0 20px; box-sizing: border-box;
        }
        .wii-btn-round {
            width: 40px; height: 40px; background: #eee; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            border: 2px solid #aaa; color: #888; font-weight: bold; font-size: 0.8rem;
        }

        /* HUD JOGO */
        #game-ui { pointer-events: none; }
        .hud-element { pointer-events: auto; }
        #hud-score { font-family: 'Russo One', sans-serif; text-shadow: 2px 2px 0 #000; }
        
        /* VOLANTE NOVO MAIS BONITO */
        .steering-wheel {
            width: 140px; height: 140px;
            border: 8px solid #ccc;
            border-radius: 50%;
            background: radial-gradient(circle, transparent 40%, rgba(0,0,0,0.8) 41%);
            box-shadow: 0 0 20px rgba(0,0,0,0.5), inset 0 0 10px rgba(0,0,0,0.8);
            position: relative;
            transition: transform 0.1s;
        }
        .wheel-center-mark {
            position: absolute; top: -8px; left: 50%; transform: translateX(-50%);
            width: 10px; height: 20px; background: red;
            border-radius: 2px;
            box-shadow: 0 0 5px red;
        }
        .wheel-spoke {
            position: absolute; top: 50%; left: 0; width: 100%; height: 15px;
            background: #888; transform: translateY(-50%);
            z-index: -1;
        }

        /* Controles de Toque */
        .btn-action {
            background: linear-gradient(to bottom, #4facfe 0%, #00f2fe 100%);
            border: 2px solid white; color: white;
            padding: 15px 30px; border-radius: 50px;
            font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

    </style>
</head>
<body>

<div id="game-hardware">
    <video id="video-source" playsinline></video>
    <video id="webcam" autoplay muted playsinline></video>
    <canvas id="game-canvas"></canvas>
</div>

<div id="os-layer">

    <div id="screen-safety" class="screen">
        <div class="safety-card">
            <h1 class="text-xl md:text-2xl font-bold mb-4">Sa√∫de e Seguran√ßa</h1>
            <p class="mb-6 text-sm text-gray-600">
                ‚ö†Ô∏è Mantenha dist√¢ncia da tela e certifique-se de ter espa√ßo livre ao seu redor para se mover.
            </p>
            <button onclick="System.boot()" class="btn-action text-lg animate-pulse">
                Tocar para Iniciar (A)
            </button>
            <div id="boot-log" class="mt-4 text-xs text-cyan-500 font-mono h-4"></div>
        </div>
    </div>

    <div id="screen-load" class="screen hidden" style="background: #000; color: #fff;">
        <div class="w-12 h-12 border-4 border-cyan-500 border-t-transparent rounded-full animate-spin mb-4"></div>
        <p class="font-mono text-sm">CARREGANDO SISTEMA...</p>
    </div>

    <div id="screen-menu" class="screen hidden">
        <div class="wii-grid">
            <div onclick="System.launch('drive')" class="channel">
                <div class="channel-icon">üèéÔ∏è</div>
                <div class="channel-name">Kart do Otto</div>
            </div>
            <div onclick="System.launch('run')" class="channel">
                <div class="channel-icon">üèÉ</div>
                <div class="channel-name">Otto Runner</div>
            </div>
            <div onclick="System.launch('fight')" class="channel">
                <div class="channel-icon">ü•ä</div>
                <div class="channel-name">Otto Boxing</div>
            </div>
            <div class="channel">
                <div class="channel-icon">üôÇ</div>
                <div class="channel-name"> Channel</div>
            </div>
            <div class="channel channel-empty"></div>
            <div class="channel channel-empty"></div>
            <div class="channel channel-empty"></div>
            <div class="channel channel-empty"></div>
        </div>

        <div class="bottom-bar justify-between">
            <div class="wii-btn-round">Otto</div>
            <div class="text-gray-500 font-bold text-sm tracking-widest">MENU</div>
            <div id="clock" class="text-gray-600 font-bold text-lg">00:00</div>
        </div>
    </div>

    <div id="game-ui" class="screen hidden" style="background: transparent;">
        <button onclick="System.home()" class="hud-element absolute top-4 right-4 bg-blue-500/80 text-white w-10 h-10 rounded-full border-2 border-white flex items-center justify-center font-bold text-[10px] shadow-lg">
            ‚åÇ
        </button>

        <div class="absolute top-4 left-4 bg-black/60 px-4 py-2 rounded-full border border-white/30">
            <span class="text-[10px] text-cyan-300 block leading-none">SCORE</span>
            <div id="hud-score" class="text-2xl text-white leading-none">0</div>
        </div>

        <div id="game-msg" class="absolute top-1/3 w-full text-center text-4xl md:text-6xl text-yellow-400 font-black drop-shadow-lg" style="text-shadow: 2px 2px 0 #000;"></div>

        <div id="ui-wheel" class="absolute bottom-24 left-1/2 -translate-x-1/2 opacity-0 transition-opacity pointer-events-none">
            <div id="visual-wheel" class="steering-wheel">
                <div class="wheel-center-mark"></div>
                <div class="wheel-spoke"></div>
            </div>
        </div>

        <div class="hud-element absolute bottom-4 left-1/2 -translate-x-1/2 bg-black/50 px-4 py-2 rounded-full flex gap-2 items-center">
            <span class="text-[10px] text-white">SENS</span>
            <input type="range" min="0.5" max="3.0" step="0.5" value="1.0" class="w-20 accent-cyan-400" oninput="System.setSens(this.value)">
        </div>
    </div>

    <div id="screen-over" class="screen hidden" style="background: rgba(255,255,255,0.95); z-index: 60;">
        <h1 class="text-5xl text-gray-800 font-black mb-2">FIM</h1>
        <div class="text-xl text-cyan-600 font-bold">PONTUA√á√ÉO</div>
        <div id="final-score" class="text-7xl text-gray-800 font-bold mb-8 font-mono">0</div>
        <div class="flex flex-col gap-3 w-64">
            <button onclick="System.restart()" class="btn-action">JOGAR NOVAMENTE</button>
            <button onclick="System.menu()" class="text-gray-500 font-bold py-2">Voltar ao Menu</button>
        </div>
    </div>

</div>

<script>
    /* =================================================================
       üîä AUDIO (Sintetizador Web Audio API)
       ================================================================= */
    const Sfx = {
        ctx: null,
        init: () => { 
            window.AudioContext = window.AudioContext || window.webkitAudioContext; 
            Sfx.ctx = new AudioContext(); 
        },
        play: (freq, type, dur, vol=0.1) => {
            if(!Sfx.ctx) return;
            const o = Sfx.ctx.createOscillator(); const g = Sfx.ctx.createGain();
            o.type=type; o.frequency.value=freq;
            g.gain.setValueAtTime(vol, Sfx.ctx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, Sfx.ctx.currentTime+dur);
            o.connect(g); g.connect(Sfx.ctx.destination);
            o.start(); o.stop(Sfx.ctx.currentTime+dur);
        },
        // Sons
        hover: () => Sfx.play(800, 'sine', 0.05, 0.02),
        click: () => Sfx.play(1200, 'sine', 0.1, 0.1),
        coin: () => { Sfx.play(1500,'square',0.1, 0.05); setTimeout(()=>Sfx.play(2000,'square',0.1, 0.05), 80); },
        hit: () => Sfx.play(150,'sawtooth',0.1, 0.2),
        crash: () => Sfx.play(80,'sawtooth',0.4, 0.4),
        skid: () => Sfx.play(60, 'sawtooth', 0.2, 0.2) // Som de derrapagem
    };

    /* =================================================================
       üé® GRAPHICS (Escal√°vel)
       ================================================================= */
    const Gfx = {
        mapPoint: (p, w, h) => {
            return {
                x: w - (p.x / 640 * w),
                y: p.y / 480 * h
            };
        },

        drawSkeleton: (ctx, pose, w, h) => {
            if(!pose) return;
            ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle='#00ffff'; ctx.lineWidth = w * 0.015;

            const kp = pose.keypoints;
            const get = n => kp.find(k=>k.name===n);
            
            const bone = (n1, n2) => {
                const p1 = get(n1); const p2 = get(n2);
                if(p1 && p2 && p1.score>0.3 && p2.score>0.3) {
                    const mp1 = Gfx.mapPoint(p1, w, h);
                    const mp2 = Gfx.mapPoint(p2, w, h);
                    ctx.beginPath(); ctx.moveTo(mp1.x, mp1.y); ctx.lineTo(mp2.x, mp2.y); ctx.stroke();
                }
            };
            
            bone('left_shoulder','left_elbow'); bone('left_elbow','left_wrist');
            bone('right_shoulder','right_elbow'); bone('right_elbow','right_wrist');
            bone('left_shoulder','right_shoulder');

            const lw = get('left_wrist'); const rw = get('right_wrist');
            const gloveSize = w * 0.08; 
            if(lw && lw.score>0.3) { const p = Gfx.mapPoint(lw, w, h); ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(p.x, p.y, gloveSize, 0, Math.PI*2); ctx.fill(); }
            if(rw && rw.score>0.3) { const p = Gfx.mapPoint(rw, w, h); ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(p.x, p.y, gloveSize, 0, Math.PI*2); ctx.fill(); }
        },

        drawRoad: (ctx, w, h, pos, curve) => {
            const cx = w/2; const horizon = h * 0.4;
            // C√©u e Ch√£o
            ctx.fillStyle = '#111'; ctx.fillRect(0,0,w,h);
            ctx.strokeStyle = '#00ffcc'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, horizon); ctx.lineTo(w, horizon); ctx.stroke();

            // Pista
            ctx.fillStyle = '#333'; ctx.beginPath();
            const topW = w * 0.05; 
            const botW = w * 1.2;  
            const curveOffset = curve * (w * 0.3);

            ctx.moveTo(cx + curveOffset - topW, horizon); 
            ctx.lineTo(cx + curveOffset + topW, horizon);
            ctx.lineTo(cx + botW, h); 
            ctx.lineTo(cx - botW, h); 
            ctx.fill();

            // Linha Central
            ctx.strokeStyle = '#ffeb3b'; ctx.lineWidth = w * 0.02;
            ctx.setLineDash([h*0.05, h*0.05]); ctx.lineDashOffset = -pos;
            ctx.beginPath(); ctx.moveTo(cx + curveOffset, horizon);
            ctx.quadraticCurveTo(cx + (curveOffset*0.5), h*0.7, cx, h); ctx.stroke();
            ctx.setLineDash([]);
        },

        drawCar: (ctx, x, y, steer, w) => {
            ctx.save(); ctx.translate(x, y); ctx.rotate(steer); 
            const s = w * 0.003; 
            ctx.scale(s, s); 
            
            ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(-25, -10, 50, 40);
            ctx.fillStyle = '#ff0033'; ctx.beginPath(); ctx.roundRect(-20, -20, 40, 40, 5); ctx.fill();
            ctx.fillStyle = '#111'; ctx.fillRect(-15, -10, 30, 10);
            ctx.fillStyle = '#ffcc00'; ctx.fillRect(-18, -18, 8, 5); ctx.fillRect(10, -18, 8, 5);
            ctx.restore();
        }
    };

    /* =================================================================
       üß† SYSTEM CORE
       ================================================================= */
    const System = {
        video: null, canvas: null, ctx: null, detector: null,
        activeGame: null, loopId: null, sens: 1.0,

        boot: async () => {
            document.getElementById('boot-log').innerText = "Iniciando C√¢mera...";
            Sfx.init(); Sfx.click();

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: {ideal: 640}, height: {ideal: 480} },
                    audio: false
                });
                System.video = document.getElementById('video-source');
                System.video.srcObject = stream;
                document.getElementById('webcam').srcObject = stream;

                await new Promise(r => System.video.onloadedmetadata = r);
                System.video.play(); document.getElementById('webcam').play();

                document.getElementById('screen-safety').classList.add('hidden');
                document.getElementById('screen-load').classList.remove('hidden');

                await tf.setBackend('webgl');
                System.detector = await poseDetection.createDetector(
                    poseDetection.SupportedModels.MoveNet,
                    { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
                );

                System.canvas = document.getElementById('game-canvas');
                System.ctx = System.canvas.getContext('2d');
                System.resize(); window.addEventListener('resize', System.resize);

                document.getElementById('screen-load').classList.add('hidden');
                System.menu();

            } catch(e) { 
                alert("Erro: Permita o uso da c√¢mera! " + e.message); 
            }
        },

        menu: () => {
            System.stopGame();
            document.getElementById('screen-menu').classList.remove('hidden');
            document.getElementById('screen-over').classList.add('hidden');
            document.getElementById('game-ui').classList.add('hidden');
            document.getElementById('webcam').style.opacity = '0';
        },

        launch: (gameId) => {
            Sfx.click();
            System.activeGame = gameId;
            document.getElementById('screen-menu').classList.add('hidden');
            document.getElementById('game-ui').classList.remove('hidden');
            document.getElementById('webcam').style.opacity = '0.3';

            const wheel = document.getElementById('ui-wheel');
            wheel.style.opacity = (gameId==='drive') ? '1' : '0';

            if(gameId==='drive') Logic.Drive.init();
            if(gameId==='run') Logic.Run.init();
            if(gameId==='fight') Logic.Fight.init();

            System.loop();
        },

        loop: async () => {
            if(!System.activeGame) return;

            const ctx = System.ctx; 
            const w = System.canvas.width; 
            const h = System.canvas.height;

            let pose = null;
            try {
                const poses = await System.detector.estimatePoses(System.video, {flipHorizontal: false});
                if(poses.length>0) pose = poses[0];
            } catch(e){}

            let score = 0;
            if(System.activeGame==='drive') score = Logic.Drive.update(ctx, w, h, pose);
            if(System.activeGame==='run') score = Logic.Run.update(ctx, w, h, pose);
            if(System.activeGame==='fight') score = Logic.Fight.update(ctx, w, h, pose);

            document.getElementById('hud-score').innerText = score;
            System.loopId = requestAnimationFrame(System.loop);
        },

        stopGame: () => {
            System.activeGame = null;
            if(System.loopId) cancelAnimationFrame(System.loopId);
        },

        home: () => { Sfx.click(); System.menu(); },
        
        gameOver: (score) => {
            System.stopGame(); Sfx.crash();
            document.getElementById('final-score').innerText = score;
            document.getElementById('game-ui').classList.add('hidden');
            document.getElementById('screen-over').classList.remove('hidden');
        },

        restart: () => System.menu(),
        setSens: (v) => System.sens = parseFloat(v),
        msg: (txt) => {
            const el = document.getElementById('game-msg');
            el.innerText = txt;
            setTimeout(()=>el.innerText='', 1500);
        },
        resize: () => {
            if(System.canvas) {
                System.canvas.width = window.innerWidth;
                System.canvas.height = window.innerHeight;
            }
        }
    };

    /* =================================================================
       üéÆ L√ìGICA DE JOGO (ATUALIZADA)
       ================================================================= */
    const Logic = {
        
        // --- JOGO 1: KART (COM OBST√ÅCULOS E VOLANTE VISUAL) ---
        Drive: {
            speed: 0, pos: 0, x: 0, steer: 0, curve: 0, obs: [],
            init: () => { Logic.Drive.speed=0; Logic.Drive.pos=0; Logic.Drive.x=0; Logic.Drive.obs=[]; System.msg("DIRIJA!"); },
            update: (ctx, w, h, pose) => {
                const d = Logic.Drive; const cx = w/2;
                
                // 1. INPUT (Volante)
                let targetAngle = 0;
                if(pose) {
                    const kp = pose.keypoints;
                    const lw = kp.find(k=>k.name==='left_wrist');
                    const rw = kp.find(k=>k.name==='right_wrist');
                    if(lw && rw && lw.score>0.3 && rw.score>0.3) {
                        const dy = rw.y - lw.y; 
                        const dx = rw.x - lw.x;
                        targetAngle = Math.atan2(dy, dx) * 1.5 * System.sens;
                        if(d.speed < h*0.05) d.speed += h*0.0005; // Acelera√ß√£o
                    } else { d.speed *= 0.95; } // Freio motor
                }
                d.steer += (targetAngle - d.steer) * 0.2;
                
                // 2. ATUALIZA VOLANTE VISUAL
                const wheel = document.getElementById('visual-wheel');
                if(wheel) wheel.style.transform = `rotate(${d.steer * 57}deg)`;

                // 3. GERA√á√ÉO DE OBST√ÅCULOS
                if(Math.random() < 0.02 && d.speed > 5) { // 2% chance por frame
                    // Posi√ß√£o lateral aleat√≥ria (-1 a 1)
                    d.obs.push({x: (Math.random()*2)-1, z: 1000}); 
                }

                // 4. F√çSICA
                d.pos += d.speed;
                d.curve = Math.sin(d.pos * 0.005) * 1.5;
                d.x += d.steer * (d.speed / (h*0.5));
                d.x -= d.curve * (d.speed / (h));

                if(Math.abs(d.x) > 1.3) { d.speed *= 0.9; } // Colis√£o borda

                // 5. DESENHO
                Gfx.drawRoad(ctx, w, h, d.pos, d.curve);

                // Desenhar e controlar Obst√°culos
                d.obs.forEach((o, i) => {
                    o.z -= (d.speed * 2); // Velocidade relativa ao carro
                    
                    if(o.z < -100) { d.obs.splice(i,1); return; } // Remove se passou

                    const scale = 500/(o.z+100);
                    if(scale > 0 && o.z < 1000) {
                        // Calcula posi√ß√£o projetada na pista curva
                        const curveOffset = d.curve * (w * 0.3) * (1 - (o.z/1000)); // Efeito parallax da curva
                        const ox = cx + curveOffset + (o.x * w * 0.5 * scale); // Posi√ß√£o lateral
                        const oy = (h * 0.4) + (50 * scale); // Altura do horizonte
                        const sz = (w * 0.08) * scale; // Tamanho

                        // Desenha Obst√°culo (Tri√¢ngulo/Cone)
                        ctx.fillStyle = '#ff9900'; 
                        ctx.beginPath();
                        ctx.moveTo(ox, oy - sz);
                        ctx.lineTo(ox - sz/2, oy);
                        ctx.lineTo(ox + sz/2, oy);
                        ctx.fill();

                        // Colis√£o Carro x Obst√°culo
                        // Se o Z for pr√≥ximo (0-100) e o X for pr√≥ximo do carro
                        if(o.z < 100 && o.z > 0) {
                            // Carro X est√° em d.x (-1 a 1 relativo a tela?), Obst√°culo em o.x (-1 a 1 relativo a pista)
                            // Aproxima√ß√£o simples:
                            const carXRel = d.x; // Posi√ß√£o do carro normalizada
                            const obsXRel = o.x; // Posi√ß√£o do obst√°culo normalizada
                            if(Math.abs(carXRel - obsXRel) < 0.3) {
                                d.speed *= 0.5; // Perde velocidade
                                Sfx.skid();
                                d.obs.splice(i,1); // Remove obst√°culo
                                ctx.fillStyle = 'rgba(255,0,0,0.5)'; // Flash vermelho
                                ctx.fillRect(0,0,w,h);
                            }
                        }
                    }
                });

                const carX = cx + (d.x * w * 0.25);
                Gfx.drawCar(ctx, carX, h * 0.85, d.steer, w);

                return Math.floor(d.pos/100);
            }
        },

        // --- JOGO 2: CORRIDA RUA (MANTIDO) ---
        Run: {
            lane: 0, score: 0, frame: 0, obs: [],
            init: () => { Logic.Run.score=0; Logic.Run.obs=[]; System.msg("CORRA!"); },
            update: (ctx, w, h, pose) => {
                const r = Logic.Run; const cx = w/2; r.frame++;
                if(pose) {
                    const nose = pose.keypoints.find(k=>k.name==='nose');
                    if(nose && nose.score > 0.4) {
                        if(nose.x < 210) r.lane = 1; else if(nose.x > 430) r.lane = -1; else r.lane = 0;
                    }
                }
                if(r.frame%50===0) r.obs.push({l: Math.floor(Math.random()*3)-1, z: 1000});
                ctx.clearRect(0,0,w,h);
                ctx.fillStyle = '#111'; ctx.fillRect(0,0,w,h);
                ctx.strokeStyle='#00ffcc'; ctx.lineWidth=1;
                ctx.beginPath(); ctx.moveTo(cx - (w*0.3), h/2); ctx.lineTo(0,h); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(cx + (w*0.3), h/2); ctx.lineTo(w,h); ctx.stroke();
                r.obs.forEach((o, i) => {
                    o.z -= 20; 
                    if(o.z < -100) { r.obs.splice(i,1); r.score+=10; Sfx.coin(); }
                    const scale = 500/(o.z+100);
                    if(scale > 0) {
                        const laneWidth = w * 0.3; const ox = cx + (o.l * laneWidth * scale);
                        const oy = h/2 + (50 * scale); const sz = (w * 0.15) * scale;
                        ctx.fillStyle = '#ff3300'; ctx.fillRect(ox-sz/2, oy, sz, sz);
                        if(o.z < 50 && o.z > -50 && o.l === r.lane) { System.gameOver(r.score); }
                    }
                });
                ctx.save(); ctx.translate(cx + (r.lane * w * 0.25), h * 0.85);
                const pScale = w * 0.005; ctx.scale(pScale, pScale);
                ctx.strokeStyle='#00ff00'; ctx.lineWidth=3; ctx.lineCap='round';
                const s = Math.sin(r.frame*0.5)*10;
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,-15); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-8+s, 20); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(8-s, 20); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(-10-s, -5); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(10+s, -5); ctx.stroke();
                ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(0,-22,5,0,Math.PI*2); ctx.fill();
                ctx.restore();
                return r.score;
            }
        },

        // --- JOGO 3: BOXE (MANTIDO) ---
        Fight: {
            score: 0, targets: [], last: 0,
            init: () => { Logic.Fight.score=0; Logic.Fight.targets=[]; System.msg("BOXE!"); },
            update: (ctx, w, h, pose) => {
                const f = Logic.Fight; const now = Date.now();
                ctx.clearRect(0,0,w,h);
                Gfx.drawSkeleton(ctx, pose, w, h);
                let punches = [];
                if(pose) {
                    const kp = pose.keypoints;
                    const lw = kp.find(k=>k.name==='left_wrist');
                    const rw = kp.find(k=>k.name==='right_wrist');
                    if(lw && lw.score>0.3) punches.push(Gfx.mapPoint(lw, w, h));
                    if(rw && rw.score>0.3) punches.push(Gfx.mapPoint(rw, w, h));
                }
                if(now - f.last > 800) {
                    const tx = (Math.random() * (w * 0.8)) + (w * 0.1);
                    const ty = (Math.random() * (h * 0.5)) + (h * 0.1);
                    f.targets.push({x: tx, y: ty, r: w*0.08, s: now});
                    f.last = now;
                }
                f.targets.forEach((t, i) => {
                    const age = (now - t.s)/1500;
                    if(age>1) { f.targets.splice(i,1); return; }
                    ctx.beginPath(); ctx.arc(t.x, t.y, t.r, 0, Math.PI*2);
                    ctx.fillStyle=`rgba(255,255,0,${1-age})`; ctx.fill();
                    ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.stroke();
                    punches.forEach(p => {
                        if(Math.hypot(p.x - t.x, p.y - t.y) < t.r + (w*0.05)) {
                            f.targets.splice(i,1); f.score += 100; Sfx.hit();
                        }
                    });
                });
                return f.score;
            }
        }
    };

    // Rel√≥gio
    setInterval(() => {
        const d = new Date();
        document.getElementById('clock').innerText = d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    }, 1000);

</script>
</body>
</html>

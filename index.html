<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>thIAguinho Wii: ORIGINAL FIXED</title>
    
    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@4.16.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@4.16.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.16.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.2"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Russo+One&display=swap');

        body {
            background-color: #000;
            margin: 0; overflow: hidden;
            font-family: 'Russo One', sans-serif;
            touch-action: none;
            user-select: none;
        }

        #game-container { position: relative; width: 100vw; height: 100vh; background: #000; }

        /* V√çDEO */
        #webcam {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            opacity: 0.4;
            z-index: 0;
        }
        #video-source { display: none; }

        #game-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
        }

        /* CURSOR WII */
        #wii-cursor {
            position: absolute;
            width: 40px;
            height: 40px;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="white" stroke="%2300ffcc" stroke-width="2"/></svg>') no-repeat center;            background-size: contain;
            pointer-events: none;
            z-index: 100;
            transition: transform 0.1s;
            opacity: 0;
        }

        /* UI */
        .layer {
            position: absolute; inset: 0;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 50;
            transition: opacity 0.4s ease-in-out;
        }
        .hidden { display: none !important; }
        .interactive { pointer-events: auto !important; }

        /* Bot√µes Estilo Original */
        .btn-main {
            background: linear-gradient(to bottom, #00ffcc, #009977);
            border: 3px solid #fff;
            color: #003322;
            text-transform: uppercase;
            box-shadow: 0 0 15px #00ffcc;
            transition: transform 0.1s;
        }
        .btn-main:active { transform: scale(0.95); }

        /* HUD */
        .hud-box {
            background: rgba(0,0,0,0.8);
            border: 2px solid #fff;
            padding: 10px 20px;
            border-radius: 8px;
        }

        /* Estilo Wii Icon */
        .wii-icon {
            background: linear-gradient(135deg, #1e3a8a, #0c4a6e);
            border: 2px solid #00ffcc;
            box-shadow: 0 8px 16px rgba(0, 255, 204, 0.3);
            backdrop-filter: blur(4px);
            transition: all 0.3s ease;
        }
        .wii-icon:hover {
            transform: scale(1.1);
            box-shadow: 0 0 25px #00ffcc, 0 12px 24px rgba(0, 255, 204, 0.5);
            border-color: white;
        }    </style>
</head>
<body>
    <div id="game-container">
        <video id="video-source" playsinline></video>
        <video id="webcam" autoplay muted playsinline></video>
        <canvas id="game-canvas"></canvas>
        <div id="wii-cursor"></div>

        <!-- TELA DE MENU PRINCIPAL (ESTILO WII) -->
        <div id="screen-wii-menu" class="layer bg-gradient-to-b from-blue-900 to-black hidden interactive">
            <div class="absolute inset-0 opacity-30" style="background: radial-gradient(circle, rgba(0,255,204,0.1) 0%, transparent 70%);"></div>
            <h1 class="text-6xl md:text-8xl text-white font-bold mb-12 text-center drop-shadow-[0_0_20px_rgba(0,255,204,0.8)]">
                thIAguinho<br><span class="text-cyan-400">Wii</span>
            </h1>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-8 max-w-2xl w-full px-4">
                <div onclick="Sfx.select(); Core.launch('drive')" class="wii-icon p-6 rounded-2xl flex flex-col items-center justify-center group cursor-pointer">
                    <div class="text-6xl mb-3">üèéÔ∏è</div>
                    <h3 class="text-xl text-white font-bold">CORRIDA</h3>
                </div>
                <div onclick="Sfx.select(); Core.launch('run')" class="wii-icon p-6 rounded-2xl flex flex-col items-center justify-center group cursor-pointer">
                    <div class="text-6xl mb-3">üèÉ</div>
                    <h3 class="text-xl text-white font-bold">RUA</h3>
                </div>
                <div onclick="Sfx.select(); Core.launch('fight')" class="wii-icon p-6 rounded-2xl flex flex-col items-center justify-center group cursor-pointer">
                    <div class="text-6xl mb-3">ü•ä</div>
                    <h3 class="text-xl text-white font-bold">BOXE</h3>
                </div>
            </div>
            <div class="absolute bottom-6 text-gray-400 text-sm">
                Use os movimentos do corpo para jogar ‚Ä¢ thIAguinho Solu√ß√µes
            </div>
        </div>

        <div id="screen-loading" class="layer bg-black/95 hidden">
            <div class="w-16 h-16 border-4 border-cyan-500 border-t-transparent rounded-full animate-spin mb-4"></div>
            <h2 class="text-white text-xl">CARREGANDO SISTEMA...</h2>
        </div>

        <div id="screen-hud" class="layer hidden justify-between p-4 pointer-events-none !items-start">
            <div class="w-full flex justify-between">
                <div class="hud-box">
                    <div class="text-[10px] text-cyan-400 font-bold uppercase">SCORE</div>
                    <div id="hud-score" class="text-3xl text-white font-mono leading-none">0000</div>
                </div>
                <button onclick="Core.quit()" class="interactive bg-red-600 hover:bg-red-500 text-white w-12 h-12 rounded-full font-bold border-2 border-white text-xl">X</button>
            </div>
            <div id="game-msg" class="absolute top-1/3 w-full text-center text-4xl text-yellow-400 font-black drop-shadow-md"></div>
            <div id="ui-wheel" class="absolute bottom-20 left-1/2 -translate-x-1/2 opacity-0 transition-opacity">
                <div class="w-24 h-24 rounded-full border-4 border-cyan-500 flex items-center justify-center bg-black/50">                    <div id="wheel-bar" class="w-full h-2 bg-red-500 rounded"></div>
                </div>
            </div>
            <div class="interactive absolute bottom-6 right-6 bg-black/80 p-3 rounded-lg border border-white/20">
                <label class="text-[10px] text-white block text-center mb-1">SENSIBILIDADE</label>
                <input type="range" min="0.5" max="3.0" step="0.5" value="1.0" class="w-24 accent-cyan-400" oninput="Core.setSens(this.value)">
            </div>
        </div>

        <div id="screen-over" class="layer bg-red-900/95 hidden interactive z-50">
            <h1 class="text-6xl text-white font-black mb-4">GAME OVER</h1>
            <div class="text-7xl text-yellow-400 font-mono font-bold mb-8" id="final-score">0</div>
            <button onclick="Core.menu()" class="btn-main px-10 py-4 rounded-full text-xl font-bold">VOLTAR</button>
        </div>
    </div>

    <script>
        /**
         * =================================================================
         * üîä AUDIO (Sintetizador Puro)
         * =================================================================
         */
        const Sfx = {
            ctx: null,
            init: () => {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                Sfx.ctx = new AudioContext();
            },
            play: (freq, type, dur, vol = 0.1) => {
                if (!Sfx.ctx) return;
                const o = Sfx.ctx.createOscillator();
                const g = Sfx.ctx.createGain();
                o.type = type;
                o.frequency.value = freq;
                g.gain.setValueAtTime(vol, Sfx.ctx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.01, Sfx.ctx.currentTime + dur);
                o.connect(g);
                g.connect(Sfx.ctx.destination);
                o.start();
                o.stop(Sfx.ctx.currentTime + dur);
            },
            coin: () => { Sfx.play(1200, 'square', 0.1); setTimeout(() => Sfx.play(1600, 'square', 0.1), 80); },
            hit: () => { Sfx.play(100, 'sawtooth', 0.2); },
            crash: () => { Sfx.play(80, 'sawtooth', 0.5, 0.3); },
            start: () => { Sfx.play(440, 'triangle', 0.1); setTimeout(() => Sfx.play(880, 'triangle', 0.3), 100); },
            select: () => { Sfx.play(660, 'sine', 0.1, 0.2); }
        };

        /**
         * =================================================================         * üé® GRAPHICS
         * =================================================================
         */
        const Gfx = {
            drawSkeleton: (ctx, pose, w, h) => {
                if (!pose) return;
                const kp = pose.keypoints;
                const find = n => kp.find(k => k.name === n);
                const mapX = x => w - (x / 640 * w);
                const mapY = y => y / 480 * h;

                ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 6;

                const nose = find('nose');
                const ls = find('left_shoulder'); const rs = find('right_shoulder');
                const le = find('left_elbow'); const re = find('right_elbow');
                const lw = find('left_wrist'); const rw = find('right_wrist');
                const lh = find('left_hip'); const rh = find('right_hip');

                const drawBone = (p1, p2) => {
                    if (p1 && p2 && p1.score > 0.3 && p2.score > 0.3) {
                        ctx.beginPath();
                        ctx.moveTo(mapX(p1.x), mapY(p1.y));
                        ctx.lineTo(mapX(p2.x), mapY(p2.y));
                        ctx.stroke();
                    }
                };

                drawBone(ls, le); drawBone(le, lw);
                drawBone(rs, re); drawBone(re, rw);
                drawBone(ls, rs);
                if (lh && rh && lh.score > 0.2) {
                    drawBone(ls, lh); drawBone(rs, rh); drawBone(lh, rh);
                } else if (ls && rs) {
                    const midShoulderX = (ls.x + rs.x) / 2;
                    const midShoulderY = (ls.y + rs.y) / 2;
                    ctx.beginPath();
                    ctx.moveTo(mapX(midShoulderX), mapY(midShoulderY));
                    ctx.lineTo(mapX(midShoulderX), mapY(midShoulderY) + 150);
                    ctx.stroke();
                }

                if (nose && nose.score > 0.3) {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath(); ctx.arc(mapX(nose.x), mapY(nose.y - 20), 25, 0, Math.PI * 2); ctx.fill();
                }
                if (lw && lw.score > 0.3) { ctx.fillStyle = 'red'; ctx.beginPath(); ctx.arc(mapX(lw.x), mapY(lw.y), 30, 0, Math.PI * 2); ctx.fill(); }
                if (rw && rw.score > 0.3) { ctx.fillStyle = 'red'; ctx.beginPath(); ctx.arc(mapX(rw.x), mapY(rw.y), 30, 0, Math.PI * 2); ctx.fill(); }
            },
            drawRoad: (ctx, w, h, pos, curve) => {
                const cx = w / 2;
                const horizon = h * 0.4;
                ctx.fillStyle = '#050505';
                ctx.fillRect(0, 0, w, h);
                ctx.strokeStyle = '#00ffcc'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(0, horizon); ctx.lineTo(w, horizon); ctx.stroke();

                ctx.fillStyle = '#333';
                ctx.beginPath();
                const topW = 20;
                const botW = w * 1.5;
                const curveOffset = curve * 200;
                ctx.moveTo(cx + curveOffset - topW, horizon);
                ctx.lineTo(cx + curveOffset + topW, horizon);
                ctx.lineTo(cx + botW, h);
                ctx.lineTo(cx - botW, h);
                ctx.fill();

                ctx.strokeStyle = '#ffeb3b'; ctx.lineWidth = 6;
                ctx.setLineDash([40, 40]); ctx.lineDashOffset = -pos;
                ctx.beginPath();
                ctx.moveTo(cx + curveOffset, horizon);
                ctx.quadraticCurveTo(cx + (curveOffset * 0.5), h * 0.7, cx, h);
                ctx.stroke();
                ctx.setLineDash([]);
            },

            drawCar: (ctx, x, y, steer) => {
                ctx.save(); ctx.translate(x, y);
                ctx.rotate(steer);
                ctx.scale(2, 2);
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(-25, -10, 50, 40);
                ctx.fillStyle = '#ff0033';
                ctx.beginPath(); ctx.roundRect(-20, -20, 40, 40, 5); ctx.fill();
                ctx.fillStyle = '#111'; ctx.fillRect(-15, -10, 30, 10);
                ctx.fillStyle = '#ffcc00'; ctx.fillRect(-18, -18, 8, 5); ctx.fillRect(10, -18, 8, 5);
                ctx.restore();
            },

            drawRunner: (ctx, x, y, frame) => {
                ctx.save(); ctx.translate(x, y); ctx.scale(3, 3);
                ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 3; ctx.lineCap = 'round';
                const s = Math.sin(frame * 0.5) * 10;
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, -15); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-8 + s, 20); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(8 - s, 20); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, -12); ctx.lineTo(-10 - s, -5); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, -12); ctx.lineTo(10 + s, -5); ctx.stroke();                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, -22, 5, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }
        };

        /**
         * =================================================================
         * üß† ENGINE
         * =================================================================
         */
        const Core = {
            video: null, canvas: null, ctx: null, detector: null,
            active: false, mode: null, sens: 1.0, loopId: null,

            boot: async () => {
                Sfx.init();
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } },
                        audio: false
                    });
                    Core.video = document.getElementById('video-source');
                    Core.video.srcObject = stream;
                    document.getElementById('webcam').srcObject = stream;
                    await new Promise(r => Core.video.onloadedmetadata = r);
                    Core.video.play(); document.getElementById('webcam').play();

                    document.getElementById('screen-loading').classList.remove('hidden');

                    await tf.setBackend('webgl');
                    Core.detector = await poseDetection.createDetector(
                        poseDetection.SupportedModels.MoveNet,
                        { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
                    );

                    Core.canvas = document.getElementById('game-canvas');
                    Core.ctx = Core.canvas.getContext('2d');

                    document.getElementById('screen-loading').classList.add('hidden');
                    document.getElementById('screen-wii-menu').classList.remove('hidden');
                } catch (e) { alert("Erro na c√¢mera: " + e.message); }
            },

            menu: () => {
                document.getElementById('screen-wii-menu').classList.remove('hidden');
                document.getElementById('screen-hud').classList.add('hidden');
                document.getElementById('screen-over').classList.add('hidden');
            },

            launch: (m) => {                Core.mode = m; Core.active = true;
                document.getElementById('screen-wii-menu').classList.add('hidden');
                document.getElementById('screen-hud').classList.remove('hidden');
                const wheel = document.getElementById('ui-wheel');
                wheel.style.opacity = (m === 'drive') ? '1' : '0';

                if (m === 'drive') Logic.Drive.init();
                if (m === 'run') Logic.Run.init();
                if (m === 'fight') Logic.Fight.init();

                Sfx.start();
                Core.loop();
            },

            quit: () => {
                Core.active = false; cancelAnimationFrame(Core.loopId); Core.menu();
            },

            gameOver: (score) => {
                Core.active = false; cancelAnimationFrame(Core.loopId);
                Sfx.crash();
                document.getElementById('final-score').innerText = score;
                document.getElementById('screen-hud').classList.add('hidden');
                document.getElementById('screen-over').classList.remove('hidden');
            },

            setSens: (v) => Core.sens = parseFloat(v),

            msg: (txt) => {
                const el = document.getElementById('game-msg');
                el.innerText = txt;
                setTimeout(() => el.innerText = '', 1500);
            },

            getScreen: () => {
                if (!document.getElementById('screen-wii-menu').classList.contains('hidden')) return 'menu';
                if (!document.getElementById('screen-hud').classList.contains('hidden')) return 'hud';
                return 'other';
            },

            loop: async () => {
                if (!Core.active) return;
                if (Core.canvas.width !== window.innerWidth) {
                    Core.canvas.width = window.innerWidth;
                    Core.canvas.height = window.innerHeight;
                }
                const ctx = Core.ctx; const w = Core.canvas.width; const h = Core.canvas.height;

                let pose = null;
                try {                    const poses = await Core.detector.estimatePoses(Core.video, { flipHorizontal: false });
                    if (poses.length > 0) pose = poses[0];
                } catch (e) { }

                // Atualiza cursor do Wii
                if (pose && ['menu', 'hud'].includes(Core.getScreen())) {
                    const rw = pose.keypoints.find(k => k.name === 'right_wrist');
                    const cursor = document.getElementById('wii-cursor');
                    if (rw && rw.score > 0.4) {
                        const x = window.innerWidth - (rw.x / 640 * window.innerWidth);
                        const y = (rw.y / 480 * window.innerHeight);
                        cursor.style.left = (x - 20) + 'px';
                        cursor.style.top = (y - 20) + 'px';
                        cursor.style.opacity = '1';
                    } else {
                        cursor.style.opacity = '0';
                    }
                }

                let score = 0;
                if (Core.mode === 'drive') score = Logic.Drive.update(ctx, w, h, pose);
                if (Core.mode === 'run') score = Logic.Run.update(ctx, w, h, pose);
                if (Core.mode === 'fight') score = Logic.Fight.update(ctx, w, h, pose);

                document.getElementById('hud-score').innerText = score;
                Core.loopId = requestAnimationFrame(Core.loop);
            }
        };

        /**
         * =================================================================
         * üß† L√ìGICA DO JOGO
         * =================================================================
         */
        const Logic = {
            Drive: {
                speed: 0, pos: 0, x: 0, steer: 0, curve: 0,
                init: () => { Logic.Drive.speed = 0; Logic.Drive.pos = 0; Logic.Drive.x = 0; Core.msg("DIRIJA!"); },
                update: (ctx, w, h, pose) => {
                    const d = Logic.Drive;
                    const cx = w / 2;
                    let targetAngle = 0;
                    if (pose) {
                        const lw = pose.keypoints.find(k => k.name === 'left_wrist');
                        const rw = pose.keypoints.find(k => k.name === 'right_wrist');
                        if (lw && rw && lw.score > 0.3 && rw.score > 0.3) {
                            const dy = rw.y - lw.y;
                            const dx = rw.x - lw.x;
                            const rads = Math.atan2(dy, dx);
                            targetAngle = rads * 1.5 * Core.sens;                            if (d.speed < 100) d.speed += 1;
                        } else {
                            d.speed *= 0.95;
                        }
                    }
                    d.steer += (targetAngle - d.steer) * 0.2;
                    const bar = document.getElementById('wheel-bar');
                    if (bar) bar.style.transform = `rotate(${d.steer * 57}deg)`;
                    d.pos += d.speed;
                    d.curve = Math.sin(d.pos * 0.005) * 1.5;
                    d.x += d.steer * (d.speed / 500);
                    d.x -= d.curve * (d.speed / 1000);
                    if (Math.abs(d.x) > 1.2) { d.speed *= 0.9; }
                    Gfx.drawRoad(ctx, w, h, d.pos, d.curve);
                    const carX = cx + (d.x * w * 0.25);
                    Gfx.drawCar(ctx, carX, h - 80, d.steer);
                    return Math.floor(d.pos / 100);
                }
            },

            Run: {
                lane: 0, score: 0, frame: 0, obs: [],
                init: () => { Logic.Run.score = 0; Logic.Run.obs = []; Core.msg("CORRA!"); },
                update: (ctx, w, h, pose) => {
                    const r = Logic.Run;
                    const cx = w / 2;
                    r.frame++;
                    if (pose) {
                        const nose = pose.keypoints.find(k => k.name === 'nose');
                        if (nose && nose.score > 0.4) {
                            if (nose.x < 240) r.lane = 1;
                            else if (nose.x > 400) r.lane = -1;
                            else r.lane = 0;
                        }
                    }
                    if (r.frame % 50 === 0) r.obs.push({ l: Math.floor(Math.random() * 3) - 1, z: 1000 });
                    ctx.clearRect(0, 0, w, h);
                    ctx.fillStyle = '#111'; ctx.fillRect(0, 0, w, h);
                    ctx.strokeStyle = '#00ffcc'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(cx - 150, h / 2); ctx.lineTo(0, h); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(cx + 150, h / 2); ctx.lineTo(w, h); ctx.stroke();
                    r.obs.forEach((o, i) => {
                        o.z -= 20;
                        if (o.z < -100) { r.obs.splice(i, 1); r.score += 10; Sfx.coin(); }
                        const scale = 500 / (o.z + 100);
                        if (scale > 0) {
                            const ox = cx + (o.l * 200 * scale);
                            const oy = h / 2 + (50 * scale);
                            const sz = 80 * scale;
                            ctx.fillStyle = '#ff3300';                            ctx.fillRect(ox - sz / 2, oy, sz, sz);
                            if (o.z < 50 && o.z > -50 && o.l === r.lane) {
                                Core.gameOver(r.score);
                            }
                        }
                    });
                    Gfx.drawRunner(ctx, cx + (r.lane * 150), h - 100, r.frame);
                    return r.score;
                }
            },

            Fight: {
                score: 0, targets: [], last: 0,
                init: () => { Logic.Fight.score = 0; Logic.Fight.targets = []; Core.msg("BOXE!"); },
                update: (ctx, w, h, pose) => {
                    const f = Logic.Fight;
                    const now = Date.now();
                    ctx.clearRect(0, 0, w, h);
                    Gfx.drawSkeleton(ctx, pose, w, h);
                    let punches = [];
                    if (pose) {
                        const mapX = x => w - (x / 640 * w);
                        const mapY = y => y / 480 * h;
                        const lw = pose.keypoints.find(k => k.name === 'left_wrist');
                        const rw = pose.keypoints.find(k => k.name === 'right_wrist');
                        if (lw && lw.score > 0.3) punches.push({ x: mapX(lw.x), y: mapY(lw.y) });
                        if (rw && rw.score > 0.3) punches.push({ x: mapX(rw.x), y: mapY(rw.y) });
                    }
                    if (now - f.last > 800) {
                        f.targets.push({ x: Math.random() * (w - 100) + 50, y: Math.random() * (h / 2) + 50, r: 40, s: now });
                        f.last = now;
                    }
                    f.targets.forEach((t, i) => {
                        const age = (now - t.s) / 1500;
                        if (age > 1) { f.targets.splice(i, 1); return; }
                        ctx.beginPath(); ctx.arc(t.x, t.y, t.r, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255,255,0,${1 - age})`; ctx.fill();
                        ctx.strokeStyle = '#fff'; ctx.stroke();
                        punches.forEach(p => {
                            if (Math.hypot(p.x - t.x, p.y - t.y) < t.r + 30) {
                                f.targets.splice(i, 1);
                                f.score += 100;
                                Sfx.hit();
                            }
                        });
                    });
                    return f.score;
                }
            }
        };
        // Iniciar
        window.onload = () => Core.boot();
    </script>
</body>
</html>